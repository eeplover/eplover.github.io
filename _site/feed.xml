<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ePlover</title>
    <description>Front end knowledge sharing.
</description>
    <link>http://eplover.github.io/</link>
    <atom:link href="http://eplover.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 18 Apr 2016 17:28:39 +0800</pubDate>
    <lastBuildDate>Mon, 18 Apr 2016 17:28:39 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>DNS 工作原理</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;目前的流行网络协议是 TCP/IP 协议，其中的 IP 为第四版的 IPv4。这个IPv4的字长32位，为了方便人脑记忆已经转成四组十进制的数字了。例如 172.18.16.20 这样的格式。当我们利用Internet传输资料的时候，需要用到这个IP，否则资料封包怎么知道要被送到哪里去？然而对于IP的这种数字的玩意儿，记忆力实在是不怎么样。但是要上Internet一定需要IP，怎么办？  &lt;br /&gt;
为了解决这个问题，早期的做法是利用某些特定的档案将主机名称与IP做一个对应，如此一来，我们就可以通过主机名称来取得该主机的IP了。人脑对于名字的记忆力可就好多了，那就是 /etc/hosts 这个档案的用途了。 &lt;br /&gt;
可惜的是，这个方法还是有缺憾。那就是主机名称与IP的对应修改无法实时同步所有主机，所以用户端电脑每次都要重新下载一次档案才能顺利联网。随着电脑的普及数量增多，这个问题日益严重。 &lt;br /&gt;
为了解决这个问题，伯克莱大学发展处一套阶层式管理主机名称对应IP的系统，我们称它为 Berkeley Internet Name Domain，BIND。也就是目前全世界使用广泛的域名系统（Domain Name System,DNS）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dns-&quot;&gt;什么是DNS ?&lt;/h3&gt;
&lt;p&gt;Domain Name System&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dns--1&quot;&gt;为什么会有DNS ？&lt;/h3&gt;
&lt;p&gt;IP 难记，域名好记&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;当你在浏览器网址框输入 http://www.ksu.edu.tw 时，先去查询本地的 /etc/hosts 这个档案，未找到对应IP就会依据相关设定（在Linux底下就是利用 /etc/resolv.conf 这个档案）所提供的 DNS 的 IP 去进行连线查询了。这个服务器（A表示）就会这样工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;收到用户的查询请求，先查看本身有没有记录，无则向 . 查询  &lt;br /&gt;
  由于DNS是阶层式架构，每部主机只会管理自己下一级主机名&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向最顶层的 .(root)服务器 查询  &lt;br /&gt;
A 会主动向 .(root)服务器 询问 http://www.ksu.edu.tw 在哪里呢？但是 .服务器 只记录了 .tw 的资讯(因为台湾只有.tw向.注册而已)。此时会告知：“我不知 这部主机的ip啦，你应该去问 .tw服务器，我这里不管！我跟你说.tw在哪里吧”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;向第二层的 .tw服务器 查询  &lt;br /&gt;
A 接着向.tw询问 http://www.ksu.edu.tw 在哪里呢？而.tw管理的又仅有 .edu.tw、.com.tw、.gov.tw … 这几部主机，记过查询比较找到了.edu.tw的网域。所以这时候.tw又告诉A说：“你要去管理.edu.tw这个网域的主机那里去查询，我有它的IP！”。&lt;/li&gt;
  &lt;li&gt;向第三层的 .edu.tw服务器 查询  &lt;br /&gt;
同理可证，.edu.tw又告诉A应该要去.ksu.edu.tw进行查询，这里只能告知.ksu.edu.tw的IP而已。&lt;/li&gt;
  &lt;li&gt;向第四层的 .ksu.edu.tw服务器 查询  &lt;br /&gt;
等A找到.ksu.edu.tw之后，BINGO！.ksu.edu.tw说：“没错，这部主机就是我管理的，我给你说它的IP吧”。所以，A就能够查到 www.ksu.edu.tw的IP喽。&lt;/li&gt;
  &lt;li&gt;记录暂存记忆体并回报用户 &lt;br /&gt;
记录了正确的IP后，A的DNS机器不会在下次有人查询http://www.ksu.edu.tw 的时候再走一次查询流程。它会很聪明的先把查询结果缓存，以方便回应下一次的相同要求。最后将结果回报给client端。当然，那个缓存的查询结果是时间性的，当过了DNS 设定记忆的时间（通常是24小时），那缓存就会被释放。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;dig +trace eplover.github.io 来追踪查询&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Apr 2016 00:00:00 +0800</pubDate>
        <link>http://eplover.github.io/pages/2016/04/18/network-dns.html</link>
        <guid isPermaLink="true">http://eplover.github.io/pages/2016/04/18/network-dns.html</guid>
        
        <category>network</category>
        
        
        <category>pages</category>
        
      </item>
    
      <item>
        <title>CDNs 的工作原理</title>
        <description>&lt;p&gt;先看下 &lt;strong&gt;Nicholas C. Zakas&lt;/strong&gt; 的这篇文章
&lt;a href=&quot;https://www.nczonline.net/blog/2011/11/29/how-content-delivery-networks-cdns-work/&quot;&gt;How CDNs work&lt;/a&gt;。  &lt;br /&gt;
接下来的内容大部分是对这篇文章的摘抄。
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cdns-&quot;&gt;什么是 CDNs ?&lt;/h3&gt;
&lt;p&gt;Content Delivery Networks，即内容分发网络。怎么理解呢？下面引用 NCZ 的一段描述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Physics determines how fast one computer can contact another over physical connections, and so attempting to access a server in China from a computer in the United States will take longer than trying to access a U.S. server from within the U.S. To improve user experience and lower transmission costs, large companies set up servers with copies of data in strategic geographic locations around the world. This is called a CDN, and these servers are called edge servers, as they are closest on the company’s network to the end-user.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简而言之，CDNs 就是一些（缓存）服务器。设立在用户端与源服务器之间，用来存放符合缓存规则（HTTP headers设置）的数据副本。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cdns--1&quot;&gt;为什么要用 CDNs ？&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;The goal of a CDNs is to serve content to end-users with high availability and high performance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dns-&quot;&gt;DNS 解析&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;什么是 DNS&lt;/a&gt; &lt;br /&gt;
当用户代理（浏览器）发起一个域名请求，DNS服务器会对请求进行解析查询并返回相应的IP地址。如果该域名请求由CDNs负责处理则返回相应CDN域名地址。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cdns--dns-&quot;&gt;CDNs 内部 DNS 解析&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;When a user makes a request to a CDN hostname, DNS will resolve to an optimized server (based on location, availability, cost, and other metrics) and that server will handle the request.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当用户代理（浏览器）发起一个域名由CDN负责处理的DNS域名请求后，处理该DNS域名请求的CDN服务器会根据DNS解析器的IP地址做地理位置的查询，然后返回一个距离那个地理位置最近的一个CDN服务器的IP。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;访问内容&lt;/h3&gt;
&lt;p&gt;端服务器是跟浏览器缓存工作方式类似的缓存代理。当一个请求来到端服务器，服务器首先检查缓存看一下请求的内容是不是存在。缓存的key是整个包括查询字符串的URL（正如在浏览器中一样）。如果内容在缓存中，并且缓存条目没有过期，那么这份内容就直接从端服务器中提供出去。可如果，内容不在缓存里或者缓存条目已经过期，那么端服务器发一个请求到原始服务器去获取信息。原始服务器是内容的真相的源头并且能提供所有在CDN上有的内容。当端服务器从原始服务器收到响应，它把根据http响应头把内容存储在缓存里。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;维基百科&lt;/a&gt;、&lt;a href=&quot;https://www.nczonline.net/blog/2011/11/29/how-content-delivery-networks-cdns-work/&quot;&gt;How CDNs work&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Apr 2016 00:00:00 +0800</pubDate>
        <link>http://eplover.github.io/pages/2016/04/17/network-cdns.html</link>
        <guid isPermaLink="true">http://eplover.github.io/pages/2016/04/17/network-cdns.html</guid>
        
        <category>network</category>
        
        <category>CDNs</category>
        
        <category>cache</category>
        
        
        <category>pages</category>
        
      </item>
    
      <item>
        <title>JavaScript 中的 this</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1. 作为对象的方法调用&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;obj.fn() // 此时fn中的 this 指向 obj    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2. 直接调用&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fn() // 此时可以看做是 undefined.fn()       

PS：严格模式下this的值为 undefined，非严格模式下的this会被赋值为 window
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;this&quot;&gt;3. 构造函数中的 this&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var obj = new fn() // 此时fn中的 this 指向新建对象 obj
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;callapplybind--this&quot;&gt;4. call，apply，bind 可为函数指定自定义的 this&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fn.call( MyDefineObj ) // 此时fn中的 this 指向 MyDefineObj
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;dom-this-dom&quot;&gt;5. DOM事件处理函数与内联事件处理函数中的 this 指向相应的DOM节点&lt;/h4&gt;
</description>
        <pubDate>Sat, 16 Apr 2016 00:00:00 +0800</pubDate>
        <link>http://eplover.github.io/pages/2016/04/16/js-this.html</link>
        <guid isPermaLink="true">http://eplover.github.io/pages/2016/04/16/js-this.html</guid>
        
        <category>JavaScript</category>
        
        
        <category>pages</category>
        
      </item>
    
  </channel>
</rss>
